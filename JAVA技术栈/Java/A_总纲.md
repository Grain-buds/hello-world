https://blog.csdn.net/w20001118/article/details/125724647



一、Java基础篇

1.接口和抽象类的区别

2.重载和重写的区别

3.==和equals的区别

4.异常处理机制

5.HashMap原理

6.想要线程安全的HashMap怎么办？

7.ConcurrentHashMap原如何保证的线程安全？

8.HashTable与HashMap的区别

9.ArrayList和LinkedList的区别

 10.如何保证ArrayList的线程安全？

11.String、StringBuffer、StringBuilder的区别

12.hashCode和equals

13.面向对象和面向过程的区别

 4.深拷贝和浅拷贝

15.多态的作用

16.什么是反射？

二.Java多线程篇

1.进程和线程的区别，进程间如何通信

2. 什么是线程上下文切换

 3.什么是死锁

 4.死锁的必要条件

5.Synchrpnized和lock的区别

6.什么是AQS锁?

8.有哪些常见的AQS锁

10.yield()和join()区别

11.线程池七大参数

12.Java内存模型 

13.保证并发安全的三大特性？

 14.volatile

15.线程使用方式

16.ThreadLocal原理

17.什么是CAS锁

18.Synchronized锁原理和优化

19.如何根据 CPU 核心数设计线程池线程数量

三.JVM篇

1.JVM运行时数据区（内存结构）

2.什么情况下会内存溢出？

3.JVM有哪些垃圾回收算法？

4.GC如何判断对象可以被回收？

5.典型垃圾回收器

6.类加载器和双亲委派机制

7.JVM中有哪些引用？

8.类加载过程

9.JVM类初始化顺序

10..对象的创建过程

11.对象头中有哪些信息

12.JVM内存参数

13.GC的回收机制和原理

四.Mysql篇

1.MyIAm和InnoDB的区别

2.mysql事务特性

3.事务靠什么保证

4.事务的隔离级别

5.什么是快照读和当前读

6.MVCC是什么

7.MySQL有哪些索引

8.聚簇索引和非聚簇索引的区别

9.B和B+数的区别，为什么使用B+数

10.MySQL有哪些锁

11.MySQL如果做慢查询优化

12.哪些情况索引会失效

13.Mysql内连接、左连接、右连接的区别

14.sql执行顺序

15.如何设计数据库？

16.where和having的区别？

17.三大范式

18.char和varchar的区别

19.InnoDB 什么情况下会产生死锁

五.常用开发框架系列

1.什么是Spring？

2.IOC是什么？

3.AOP是什么？ 

4.循环依赖是什么，怎么解决的？

5.Bean 的作用域

6.Bean 生命周期

7.Spring 事务原理？

8.spring事务失效场景

9.spring事务的隔离级别

10.spring事务的传播行为

11.Spring IoC

12.spring用了哪些设计模式

13.SpringMV工作原理

14.springboot自动配置原理

5.springboot常用注解

六.Redis系列

1.redis为什么快？

2.redis持久化机制

3.Redis如何实现key的过期删除？

4.Redis数据类型

5.Redis缓存穿透如何解决？

6.Redis如何解决缓存击穿？

7.Redis如何解决缓存雪崩？

8.Redis分布式锁的实现原理

9.Redis集群方案

10.Redis集群主从同步原理

11.Redis缓存一致性解决方案

12.Redis内存淘汰策略

七.计算机网络系列

1.TCP/IP模型​编辑

 2.浏览器输入地址后做了什么？

 3.TCP三次握手

4.为什么TCP不能两次握手

5.TCP四次挥手

6.为什么要进入时间等待状态？

7.TCP 滑动窗口

8.TCP拥塞控制

9.TCP超时重传

10.TCP可靠传输的实现

11.TCP报头有哪些信息

 12.状态码

13.http与https的区别

14.socket通信流程

八.linux系列

1.linux常用命令

2.linux的io模型

九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等...）

1.Java如何实现统计在线人数的功能？

2.RabbitMQ如何保证消息不丢失？ 

4.设计模式六大原则

5.排序算法的时间复杂度

6.大量数据排名，采用什么数据结构

7.二叉树和堆之间联系或区别

8.hash表冲突的解决方法

