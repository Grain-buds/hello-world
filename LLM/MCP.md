# MCP概览
- Why,MCP出现是为了解决什么事情。
- How,MCP的组成
- MCP与Function Calling 的区别
- MCP的服务端
- MCP的客户端
- MCP的传输层
- MCP的还有那些要做的



## MCP的组成
MCP Host: 管理一个或者多个MCP clients（ manages one or multiple MCP clients）
MCP Client: 链接MCP Server ，获取返回的数据
MCP Server: 提供能力


### MCP与Function Calling 的区别
都是在增强 AI 模型与外部数据的交互能力，但 MCP 不止可以增强 AI 模型，还可以连接其他的应用系统。
![图片](https://pic4.zhimg.com/v2-b82dc0e2da4a258438b84484d1af8319_1440w.jpg)


### MCP 的基本工作流程
初始化连接：客户端向服务器发送连接请求，建立通信通道。
发送请求：客户端根据需求构建请求消息，并发送给服务器。
处理请求：服务器接收到请求后，解析请求内容，执行相应的操作（如查询数据库、读取文件等）。
返回结果：服务器将处理结果封装成响应消息，发送回客户端。
断开连接：任务完成后，客户端可以主动关闭连接或等待服务器超时关闭。

## MCP服务端
其功能可以细分为以下几个关键方面：
资源（Resources）：类似文件的数据，可以被客户端读取，如 API 响应或文件内容。
工具（Tools）：可以被 LLM 调用的函数（需要用户批准）。
提示（Prompts）：预先编写的模板，帮助用户完成特定任务。

### 工具（Tools）
MCP 服务器能够为大型语言模型（LLMs）提供执行具体操作的能力。例如，通过服务器端的工具接口，LLMs 可以完成从代码调试到文件管理的各类任务，从而将模型的语言生成能力转化为实际的生产力。

### 资源（Resources）

服务器负责向 LLMs 暴露来自不同数据源的内容和信息，例如企业内部数据库、云存储文件或实时 API 数据。这种资源的开放性赋予了模型更强的上下文感知能力，使其能够基于最新数据生成更准确的输出。

### 提示（Prompts）

MCP 服务器支持创建可复用的提示模板和工作流，帮助开发者设计标准化的交互模式。这种功能特别适用于需要高效迭代或批量处理的任务场景，例如自动化客服或内容生成流程。

## MCP的传输层
### 消息格式
- MCP 使用 JSON-RPC 2.0 作为其传输格式。
- 传输层负责将 MCP 协议消息转换为 JSON-RPC 格式以进行传输，并将接收到的 JSON-RPC 消息转换回 MCP 协议消息


### 传输类型

本地通信: stdio 传输通过标准输入和输出流实现通信。这对于本地集成和命令行工具特别有用
远程通信: Streamable HTTP transport


### MCP的 streamable http 协议和http 有什么差异点。
streamable http:
* 统一端点：移除了专门建立连接的 /sse 端点，将所有通信整合到统一的端点（比如/mcp）。
* 按需流式传输：服务器可以灵活选择返回标准 HTTP 响应或通过 SSE 流式返回。
* 状态管理：引入 session 机制以支持状态管理和恢复。


Streamable HTTP 架构设计优化
- 单一端点统一所有通信，消除多端点管理成本
  - 传统 SSE 的痛点：传统 SSE 需要为 “客户端发送请求” 和 “服务器推送事件” 分别设置不同端点（例如用/api处理客户端 POST 请求，用/sse处理服务器推送
- Streamable HTTP 的优化：
  - 所有通信（客户端发送消息、服务器响应、服务器主动推送）通过单一端点（如/mcp）完成，无需区分 “普通请求端点” 和 “SSE 端点”。
  - 客户端只需与这一个端点交互：用 POST 发送请求，用 GET 建立推送通道（或复用同一连接），无需维护多个连接地址。
  - 服务器端路由、权限校验、会话管理等逻辑可集中在单一端点实现，减少代码冗余和维护成本。 
- 动态协议升级，简化连接生命周期管理
  - 传统 SSE 的痛点：客户端需先判断是否需要推送，再主动发起 SSE 连接（如创建EventSource），流程固定且僵化。若后续需要从 “普通请求” 切换到 “流式推送”，需重新建立连接，增加交互成本。
  - Streamable HTTP 的优化：
    - 支持动态协议升级：客户端通过同一端点发送请求时，服务器可根据需求（如是否需要持续推送）自动决定返回 “普通 HTTP 响应” 或 “升级为 SSE 流”，无需客户端提前判断。 例如：客户端发送一个查询请求后，服务器可先返回初始结果，再自动升级为 SSE 流，后续有新数据时继续推送，避免客户端二次建立连接。 连接生命周期由服务器动态控制，客户端无需关心 “是否需要切换协议”，简化了客户端状态管理逻辑。

- 统一数据格式与交互模式，降低跨层适配成本
  - 传统 SSE 的痛点：SSE 推送的事件格式（data:、event:等）与普通 HTTP 响应格式不同，客户端需分别解析两种数据格式，增加代码复杂度
  - Streamable HTTP 的优化：
    - 定义统一的数据交互格式（如 JSON-RPC），无论是客户端发送的请求、服务器的普通响应，还是 SSE 推送的事件，都采用相同的格式规范。
    - 客户端可使用同一套解析逻辑处理所有数据，无需区分 “普通响应” 和 “推送事件”，减少跨场景的适配代码。（复用单一 HTTP 连接，服务端通过分块传输分阶段发送数据，客户端通过格式特征（如 JSON 结束符、SSE 的data:前缀）区分两个阶段）
    - 服务器端也可复用数据序列化 / 反序列化逻辑，降低多格式处理的开发成本。

总结：Streamable HTTP 通过 “单一端点 + 动态升级 + 会话绑定 + 统一格式” 的设计，将传统 SSE 的 “多端点、多连接、多格式” 架构简化为 “单端点、自适应连接、统一交互” 的模式

## 参考材料
[MCP官网](https://modelcontextprotocol.io/docs/learn/architecture)
https://docs.mcpservers.cn/introduction

