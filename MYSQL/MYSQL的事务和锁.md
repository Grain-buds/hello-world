# MYSQL的锁

## MYSQL的什么场景下使用锁
数据库的锁机制本身是为了解决并发事务带来的问题。不同的隔离级别中，工作线程执行SQL语句时，用的锁粒度、类型不同

## MYSQL有那些锁，锁分类
### 以锁粒度的维度划分
* 全局锁：锁定数据库中的所有表。加上全局锁之后，整个数据库只能允许读，不允许做任何写操作
* 表级锁：每次操作锁住整张表。主要分为三类
  * 表锁（分为表共享读锁 read lock、表独占写锁 write lock）
  * 元数据锁（meta data lock，MDL）：基于表的元数据加锁，加锁后整张表不允许其他事务操作。这里的元数据可以简单理解为一张表的表结构
  * 意向锁（分为意向共享锁、意向排他锁）：这个是InnoDB中为了支持多粒度的锁，为了兼容行锁、表锁而设计的，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查
* 行级锁：每次操作锁住对应的行数据。主要分为三类
  * 记录锁 / Record 锁：也就是行锁，一条记录和一行数据是同一个意思。防止其他事务对此行进行update和delete，在 RC、RR隔离级别下都支持
  * 间隙锁 / Gap 锁：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
  * 临键锁 / Next-Key 锁：间隙锁的升级版，同时具备记录锁+间隙锁的功能，在RR隔离级别下支持
* 以互斥性的角度划分
  * 共享锁 / S锁：不同事务之间不会相互排斥、可以同时获取的锁
  * 排他锁 / X锁：不同事务之间会相互排斥、同时只能允许一个事务获取的锁
  * 共享排他锁 / SX锁：MySQL5.7版本中新引入的锁，主要是解决SMO带来的问题
* 以思想的维度划分
  * 乐观锁：每次执行前认为自己会成功，因此先尝试执行，失败时再获取锁
  * 悲观锁：每次执行前都认为自己无法成功，因此会先获取锁，然后再执行

## MYSQL 的表级别的锁详细介绍

### 表锁
* 表共享读锁（read lock）
* 表独占写锁（write lock）
加锁：lock tables 表名... read/write
释放锁：unlock tables / 客户端断开连接


结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

备注：InnoDB是一个支持多粒度锁的存储引擎，它的锁机制是基于聚簇索引实现的，当SQL执行时，如果能在聚簇索引命中数据，则加的是行锁，如无法命中聚簇索引的数据则加的是表锁



### 元数据锁（Meta Data Lock）
Meta Data Lock元数据锁，也被简称为MDL锁。
所有存储引擎的表都会存在一个.frm文件，这个文件中主要存储表的结构（DDL语句，包括表结构的定义信息、创建删除修改表等）。而**MDL锁就是基于.frm文件中的元数据加锁**的。这里的元数据 可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。
MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性.
总结：更改表结构时使用，比如alter table，出现元数据排他锁；执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁



### 意向锁（Intention Lock）
为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。
意向共享锁（IS）：由语句select ... lock in share mode添加，与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。在准备给表数据添加一个S锁时，需要先获得该表的IS锁
意向排他锁（IX）：由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。在准备给表数据添加一个X锁时，需要先获得该表的IX锁

```sql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
-- 或者特定查看表  
select   engine_transaction_id, object_name, index_name, lock_type, lock_mode, lock_status, lock_data from performance_schema.data_locks
 where object_name = 't2' and lock_type = 'RECORD'；

```


## MYSQL 的行级别的锁详细介绍
InnoDB引擎支持行锁（不考虑那些闭源自研的），MyISAM等引擎不支持行锁。
InnoDB支持聚簇索引——将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。InnoDB中如果能够命中索引数据，就会加行锁，无法命中则会加表锁
InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：行锁、间隙锁、临键锁
[锁的定义](https://developer.qcloudimg.com/http-save/yehe-10925111/f341f6b9ed5157b2a8bce1d3dd22a1a0.png)
行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持
间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），左右开区间，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap，左开右闭。 在RR隔离级别下支持


### 记录锁（Record Lock）
行锁（Record Lock），也称为记录锁，一行表数据、一条表记录本身就是同一个含义。锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
锁住一行数据，在索引上才能加锁，非索引会升级为表级锁。
```sql
-- 获取行级别的共享锁
select * from bank_balance where id = 1 lock in share mode;
-- 获取行级别的排他锁
select * from bank_balance where id = 1 for update;
```

### 间隙锁（Gap Lock）
锁定索引记录间隙（不含该记录），左右开区间，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
间隙锁是对行锁的一种补充，主要是用来解决幻读问题的。

加间隙锁的规则:
* 索引上的等值查询
  * 假如是唯一索引，给不存在的记录加锁时, 优化为间隙锁.
  * 假如是非唯一普通索引，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
* 索引上的范围查询
  * 唯一索引 -- 会访问到不满足条件的第一个值为止
  * 

总结：RR事务隔离下，非唯一索引（等值查询和范围查询）、唯一索引范围查询，查询触发间隙锁； 唯一索引的查询不存在记录是，触发间隙锁
注意：间隙锁唯一目的是防止其他事务插入间隙。（共享锁）间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁


```sql 
-- 假如存在Id =3 和id  = 9的记录，id是主键
-- 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁，
--当对一个不存在的数据加锁后，默认就是锁定前后两条数据之间的区间，左右开区间，即锁定(3,9)、不包含3、9的区域。
-- 当其他事务再尝试向该区间插入数据时，就会陷入阻塞，只有当持有间隙锁的事务结束后，才能继续执行插入操作。
select * from bank_balance where id=6 lock in share mode;

-- 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
-- 假设stu表中age为非唯一普通索引，InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。
select * from sth where age=20 lock in share mode;

-- 索引上的范围查询(唯一索引) —— 会访问到不满足条件的第一个值为止
-- 查询的条件为id>=6，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：[6],  (6,9], (9,正无穷)。所以数据库数据在加锁是，就是将6加了行锁，9的临键锁（包含9及9之前的间隙），正无穷的临键锁(正无穷及之前的间隙)
select * from sth where id>=6 lock in share mode;


```

非唯一索引触发间隙锁的本质是 防止在重复键值范围内插入新数据导致幻读。理解这一机制有助于：
合理设计索引（优先使用唯一索引）。
在高并发场景下优化锁竞争（如选择 READ COMMITTED）。
避免大范围查询对性能的影响。
[非唯一索引案例](https://juejin.cn/post/7475688052909899802)



### 临建锁（Next-Key Lock）
一种由记录锁+间隙锁组成的锁。临键锁则是两者的结合体，加锁后，即锁定左开右闭的区间（每个临键锁是左开右闭区间），也会锁定当前行数据。间隙锁和临建锁的目的都是用来解决可重复读的问题 ，
如果在读提交级别，间隙锁和临建锁都会失效。
默认情况下， InnoDB 在 REPEATABLE READ 事务隔离级别运行， InnoDB 使用 next-key 锁进行搜
索和索引扫描，以防止幻读。以下情况退化成间隙锁
索引上的等值查询 ( 唯一索引 ) ，给不存在的记录加锁时 , 优化为间隙锁 。
索引上的等值查询 ( 非唯一普通索引 ) ，向右遍历时最后一个值不满足查询需求时， next-key lock 退化为间隙锁。



mysql的锁:  
https://blog.csdn.net/qq_40378034/article/details/90904573


mysql的事务下的脏读、幻读和不可重复读
https://blog.csdn.net/weixin_44742132/article/details/122314808