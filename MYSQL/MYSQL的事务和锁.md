# MYSQL的锁

## MYSQL的什么场景下使用锁
数据库的锁机制本身是为了解决并发事务带来的问题。不同的隔离级别中，工作线程执行SQL语句时，用的锁粒度、类型不同

## MYSQL有那些锁，锁分类
### 以锁粒度的维度划分
* 全局锁：锁定数据库中的所有表。加上全局锁之后，整个数据库只能允许读，不允许做任何写操作
* 表级锁：每次操作锁住整张表。主要分为三类
  * 表锁（分为表共享读锁 read lock、表独占写锁 write lock）
  * 元数据锁（meta data lock，MDL）：基于表的元数据加锁，加锁后整张表不允许其他事务操作。这里的元数据可以简单理解为一张表的表结构
  * 意向锁（分为意向共享锁、意向排他锁）：这个是InnoDB中为了支持多粒度的锁，为了兼容行锁、表锁而设计的，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查
* 行级锁：每次操作锁住对应的行数据。主要分为三类
  * 记录锁 / Record 锁：也就是行锁，一条记录和一行数据是同一个意思。防止其他事务对此行进行update和delete，在 RC、RR隔离级别下都支持
  * 间隙锁 / Gap 锁：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
  * 临键锁 / Next-Key 锁：间隙锁的升级版，同时具备记录锁+间隙锁的功能，在RR隔离级别下支持
* 以互斥性的角度划分
  * 共享锁 / S锁：不同事务之间不会相互排斥、可以同时获取的锁
  * 排他锁 / X锁：不同事务之间会相互排斥、同时只能允许一个事务获取的锁
  * 共享排他锁 / SX锁：MySQL5.7版本中新引入的锁，主要是解决SMO带来的问题
* 以思想的维度划分
  * 乐观锁：每次执行前认为自己会成功，因此先尝试执行，失败时再获取锁
  * 悲观锁：每次执行前都认为自己无法成功，因此会先获取锁，然后再执行

## MYSQL 的锁详细介绍

### 表锁
* 表共享读锁（read lock）
* 表独占写锁（write lock）
加锁：lock tables 表名... read/write
释放锁：unlock tables / 客户端断开连接


结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

备注：InnoDB是一个支持多粒度锁的存储引擎，它的锁机制是基于聚簇索引实现的，当SQL执行时，如果能在聚簇索引命中数据，则加的是行锁，如无法命中聚簇索引的数据则加的是表锁



### 元数据锁（Meta Data Lock）
Meta Data Lock元数据锁，也被简称为MDL锁。
所有存储引擎的表都会存在一个.frm文件，这个文件中主要存储表的结构（DDL语句，包括表结构的定义信息、创建删除修改表等）。而**MDL锁就是基于.frm文件中的元数据加锁**的。这里的元数据 可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。
MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性.
总结：更改表结构时使用，比如alter table，出现元数据排他锁；执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁



### 意向锁（Intention Lock）






mysql的锁:  
https://blog.csdn.net/qq_40378034/article/details/90904573


mysql的事务下的脏读、幻读和不可重复读
https://blog.csdn.net/weixin_44742132/article/details/122314808